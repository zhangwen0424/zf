<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 前端路由的实现原理：两种模式 一种是hash模式 一种history模式 h5api
      // window.location.hash = '/' history.pushState(state,null,url) history.replaceState()
      // 目前浏览器 都支持了history.pushState  history.pushState(state,null,url) history.pushState(state,null,'#/')

      // 两种路由的区别：
      // hash  hash模式的好处 就是锚点，刷新页面的时候不会像服务器发送请求，同时他不支持服务端渲染(不能做seo优化)。 不会产生404  忒丑
      // history 特点就是路径漂亮 没有# 和正常页面切换一样，如果刷新页面会像服务器发送请求，如果资源不存在会出现404, 解决方案 ， 渲染首页，首页会根据路径重新跳转

      // 自己实现一个路由核心模块

      const routerHistory = createWebHashHistory();
      console.log("routerHistory:", routerHistory);

      // 实现路由监听，如果路径变化 需要通知用户
      // routerHistory.listen((to, from, { isBack }) => {
      //   console.log(to, from, isBack);
      // });

      // 创建路由记录
      function createWebHashHistory(base = "") {
        // 1.路由系统最基本的 得包含当前的路径，当前路径下他的状态是什么, 需要提供两个切换路径的方法 push replace
        const historyNavigation = useHistoryStateNavigation(base);

        // const historyListeners = useHistoryListeners(
        //   base,
        //   historyNavigation.state,
        //   historyNavigation.location
        // );
        const routerHistory = Object.assign({}, historyNavigation);

        return routerHistory;
      }
      // 路由系统
      function useHistoryStateNavigation(base) {
        // 当前位置信息
        const currentLocation = {
          value: createCurrentLocation(base),
        };
        return {
          loaction: currentLocation,
        };
      }
      // 返回当前位置信息
      function createCurrentLocation(base) {
        const { pathname, search, hash } = window.location;
        // const hasPos = base.indexOf("#");
        return pathname + search + hash;
      }
    </script>
  </body>
</html>
