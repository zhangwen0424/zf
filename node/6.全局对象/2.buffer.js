// buffer是为了在node中来处理我们二进制数据  16进制

// blob 文件类型 ，我们不能直接动手操作这个blob
// arraryBuffer 可以存储二进制， 不能直接操作读取他
// 有个二进制数据类型来帮我们操作二进制 Buffer

const fs = require("fs");

const r = fs.readFileSync("./package.json");
console.log("r", r);

// 电脑的世界里只 0,1。 进制转化问题， 二进制的缺点长，不容易阅读
// 10进制  -> 2进制 8进制  16进制

// 1b = 8bit (每一个位都能放一个 0 , 1)
// 1024b = 1kb
// 1024kb = 1M
// 二进制0b开头  八进制0开头 十六进制 0x开头

// 111 是二进制 -》3 10进制  1x2^2 + 1x2^1 + 1*2^0 -> 7
// 111 是16进制 -》17 10进制 乘权求和   1 * 16 ^2 + 1 * 16 ^1 + 1 * 16 ^0 = 273
// 1111111111 + 1 -1 = 1 * 2 ^ 10 -1

// 1. parseInt 这个方法可以将任何进制转化成10进制
console.log(parseInt("1111111111", 2)); // 1023
console.log(parseInt("11", 8)); // 9
console.log(parseInt("11", 16)); // 17

// 2. toString 可以转换任何进制 转出来的是字符串
console.log((100).toString(16)); //10进制-》16 进制， 反向取余的方式来计算 64

// 0.1 + 0.2 !== 0.3  -> 二进制来存储  10进制的小数如何转化成2进制：乘2取整法
// 0.1 * 2 = 0.2
// 0.2 * 2 = 0.4
// 0.4 * 2 = 0.8
// 0.8 * 2 = 1.6
// 0.6 * 2 = 1.2
// 0.2 * 2 = 0.4
// 0.00011001001001001
console.log((0.1).toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(0.2 + 0.2); // 0.4 都是近似值,碰巧相等

// 编码问题 发展历程
// ascii  127最大值是127(0b1111111)   11111111 + 1 -1  = 2^8 - 1 = 255 (1个字节就可以表示ascii码)
// gb2312 支持简体中文  两个字节表示我们的汉字 如果两个字节大于127 我就认为这两个组合成一个汉字 有了6000多个汉字出现了
// gbk 双字节 只要第一个字节超过了 127我就认为下一个字节就是汉字的另一个部分 繁体。
// gb18030 基于gb2312和gbk 进行了扩充  可以正常使用  半角和全角

// 一个汉字 需要两个字节
// unicode 编码  统一用两个字节来表示所有的字符 255 * 255 = 65000+
// utf组织 对unicode进行编码 编程1-4个可变长度的字节 10w+字符。 可变在utf-8一个字母是一个字节   一个汉字是3个字节
// node中默认不支持gbk

// 编码方式
// base64编码 （编码格式） 明文，按照大家都知道的规则进行的转化  `base32`
// http 文本格式的协议 将二进制进行编码传输 -》字符串

// base64的核心就是让每个字节都在64位之内, 如何控制在 64 位， base64 的原理
// 转成 base64，从三个字节变成 4 个字节，体积扩大
// 将1个文字三个字节，3 * 8 个位 = 24位
console.log(Buffer.from("帅")); // <Buffer e5 b8 85>
console.log((0xe5).toString(2)); // 11100101
console.log((0xb8).toString(2)); // 10111000
console.log((0x85).toString(2)); // 10000101
// 11100101 10111000 10000101   -》 4 * 6的格式
// 每隔六位拆分，前面补两个 0 =》 00111001  00011011  00100010  00000101
console.log(parseInt("00111001", 2)); // 57
console.log(parseInt("00011011", 2)); // 27
console.log(parseInt("00100010", 2)); // 34
console.log(parseInt("00000101", 2)); // 5

let code = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
code += code.toLowerCase();
code += "0123456789";
code += "+/";
console.log(code[57] + code[27] + code[34] + code[5]); // 5biF  3个 -》 4个  1M -》 1.3M
// webpack file-loader
console.log(Buffer.from("帅").toString("base64")); // 5biF
