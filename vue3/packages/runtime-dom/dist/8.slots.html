<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <div id="app"></div>
    <script type="module">
      import {
        Text,
        Fragment,
        render,
        h,
        ref,
        toRefs,
        reactive,
      } from "../../../node_modules/@vue/runtime-dom/dist/runtime-dom.esm-browser.js";
      // import {
      //   reactive,
      //   toRefs,
      //   ref,
      //   Text,
      //   Fragment,
      //   createVNode,
      //   h,
      //   render,
      // } from "./runtime-dom.js";

      // 普通插槽 我们渲染的时候 数据都是来自于父组件的
      // 使用组件的时候 传递参数了 就是作用域插槽，会接受组件中的数据
      // 匿名插槽，都放在default中，具名插槽就是放到对应的命名下

      // 插槽的流程
      // 1.渲染组件时会传入对象，这个对象在createVNode 中标记为插槽
      // 2.组件渲染，创建实例加上属性slots,来存储他提供的 children
      // 3.组件初始化时初始化插槽initSlots，把 children放到插槽内部

      // 插槽的使用
      // 1. proxy.$slots(对 vue2 的兼容，在 render 函数中取到插槽)
      // 2. setup(props, {slots})

      const VueComponent = {
        setup(props, { slots }) {
          //let {slots} =  context    更新 context.slots = {}
          const text = ref("hello");
          console.log("slots", slots, slots.default(text.value));
          
          //  1.通过 setup中 context 取插槽
          // return () => {
          //   return h(Fragment, [
          //     slots.header(),
          //     slots.default(text.value),
          //     slots.footer(),
          //   ]);
          // };

          //  2.通过 proxy 取插槽
          return (proxy) => {
            return h(Fragment, [
              proxy.$slots.header(),
              proxy.slots.default(text.value),
              proxy.slots.footer(),
            ]);
          };
        },
      };
      // vue3 为了方便区分是插槽还是基本的虚拟节点，作区分 直接写成对象
      render(
        h(
          VueComponent,
          {},
          {
            // 组件的儿子就是插槽，而且插槽一定是一个对象
            default: (text) => h(Text, "default " + text),
            header: () => h(Text, "header"),
            footer: () => h(Text, "footer"),
          }
        ),
        app
      );
    </script>
  </body>
</html>
